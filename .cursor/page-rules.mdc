---
alwaysApply: true
scope:
  filePatterns: ["*.ts", "*.tsx", "src/**/*.ts", "src/**/*.tsx"]  # 仅对前端项目的TypeScript/TSX文件生效
  aiScenarios: ["generate", "refactor", "debug"]  # AI生成/重构/调试时都遵守
  version: "1.0.0"  # 规则版本(便于迭代)
---

# 【页面】规则约束

## 目录结构

所有页面文件必须放在 `@/pages/support/` 目录下，并按功能模块分类：

- `support/system/` - 系统管理相关页面
- `support/app/` - 应用管理相关页面
- `support/dashboard/` - 仪表盘相关页面
- `support/notification/` - 通知相关页面
- `support/[模块名]/` - 新增模块需创建对应目录

## 规则

- 所有新建页面必须放在 `support` 目录下的对应模块目录中
- 如果模块目录不存在，需要先创建模块目录
- 页面文件命名使用 PascalCase（如：`UserList.tsx`）
- 路由配置中的 `component` 路径需使用 `./support/[模块]/[页面]` 格式

## 常量使用规范

- 系统参数标识（`sys_param_flag`）的判断必须使用 `SysParamFlag` 常量：
  - `SysParamFlag.No = 0` // 否
  - `SysParamFlag.Yes = 1` // 是
- 禁止在代码中直接使用数字 `0` 或 `1` 进行 `sys_param_flag` 的判断比较
- 常量定义在 `@/utils/constants.ts` 中

## 表格字段显示规范

- **所有字段值为空时，默认必须显示空字符串 `''`，禁止显示 `-` 或其他占位符**
- **除非用户明确强调需要使用 `-` 或其他占位符，否则一律使用空字符串**
- 如果字段可能为空，需要在 `columns` 配置中添加 `render` 函数处理：`render: (_, record) => record.field_name || ''`
- 确保所有可能为空的字段都遵循此规范，保持显示的一致性

## 按钮禁用规范

- 禁用的按钮必须使用 `danger disabled` 属性，并使用 `Tooltip` 组件包裹以显示禁用原因
- 禁止在禁用按钮上单独设置 `color` 样式，保持禁用状态样式的一致性

## 批量操作规范

- **所有批量操作（批量审核、批量删除、批量启用/禁用等）必须放在 `toolBarRender` 中**
- **禁止使用 `FooterToolbar` 组件进行批量操作**
- 批量操作按钮应该：
  - 使用 `disabled` 属性控制是否可用（当 `selectedRowKeys.length === 0` 时禁用）
  - 通过 `Modal` 或 `Popconfirm` 进行二次确认
  - 显示操作状态（loading 状态）
- 批量操作按钮应与其他操作按钮（如"新增"按钮）一起放在 `toolBarRender` 数组中
- 使用 `.filter(Boolean)` 过滤掉条件渲染时的 `null` 值，保持代码整洁
- **当页面存在批量选择功能（`rowSelection`）时，单个删除/编辑操作成功后，必须同步更新 `selectedRowKeys` 状态**
  - 单个删除成功后，需要从 `selectedRowKeys` 中移除已删除项的 ID
  - 确保"已选择 X 项"的显示数据与实际选中状态保持一致

## 分页重置规范

- 当切换 tab、筛选条件或查询条件改变时，必须重置分页到第一页
- 使用 `actionRef.current?.reloadAndRest?.()` 方法进行重置分页并重新加载数据
- 禁止使用 `actionRef.current?.reload()` 在条件改变时重新加载，避免出现无数据的情况

### 批量操作范例

```typescript
// 状态管理
const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);
const [batchAuditVisible, setBatchAuditVisible] = useState(false);
const [batchAuditLoading, setBatchAuditLoading] = useState(false);

// 单个删除处理函数（需要更新选中状态）
const handleDelete = async (record: any) => {
  try {
    const res = await deleteItem({ id: record.id });
    if (res.code === 200) {
      message.success('删除成功');
      // 从选中列表中移除已删除的项
      setSelectedRowKeys((prev) =>
        prev.filter((key) => key !== record.id),
      );
      actionRef.current?.reload();
    }
  } catch (error) {
    message.error('删除失败');
  }
};

// 批量操作处理函数
const handleBatchAudit = async () => {
  if (selectedRowKeys.length === 0) {
    message.warning('请至少选择一条数据');
    return;
  }

  setBatchAuditLoading(true);
  try {
    const res = await batchAudit({ ids: selectedRowKeys });
    if (res.code === 200) {
      message.success('批量审核成功');
      setBatchAuditVisible(false);
      setSelectedRowKeys([]);
      actionRef.current?.reload();
    }
  } catch (error) {
    message.error('批量审核失败');
  } finally {
    setBatchAuditLoading(false);
  }
};

// ProTable 配置
<ProTable
  rowSelection={{
    selectedRowKeys,
    onChange: (keys) => setSelectedRowKeys(keys),
  }}
  toolBarRender={() => [
    <Button
      key="add"
      type="primary"
      icon={<PlusOutlined />}
      onClick={handleAdd}
    >
      新增
    </Button>,
    <Button
      key="batchAudit"
      type="primary"
      disabled={selectedRowKeys.length === 0}
      onClick={() => setBatchAuditVisible(true)}
    >
      批量审核
    </Button>,
    <Button
      key="batchDelete"
      danger
      disabled={selectedRowKeys.length === 0}
      onClick={() => {
        Modal.confirm({
          title: '确定要批量删除选中的数据吗？',
          onOk: handleBatchDelete,
        });
      }}
    >
      批量删除
    </Button>,
  ]}
/>

// 批量操作确认 Modal
<Modal
  title="批量审核"
  open={batchAuditVisible}
  onOk={handleBatchAudit}
  onCancel={() => setBatchAuditVisible(false)}
  confirmLoading={batchAuditLoading}
>
  <div>已选择 <strong>{selectedRowKeys.length}</strong> 条数据</div>
  {/* 其他审核选项 */}
</Modal>
```

**参考实现：** `src/pages/user/components/UserList.tsx`（批量审核功能）
